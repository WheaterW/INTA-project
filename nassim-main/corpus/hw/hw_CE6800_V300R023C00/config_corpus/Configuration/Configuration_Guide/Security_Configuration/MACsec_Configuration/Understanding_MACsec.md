Understanding MACsec
====================

MACsec is used on a point-to-point link between interfaces of two devices. The local and remote ends use security keys to encrypt and decrypt data packets. The MACsec Key Agreement (MKA) protocol provides key negotiation as well as establishment and management of secure channels. The MKA protocol defines a complex key generation system to ensure the security of MACsec data transmission. A Connectivity Association Key (CAK) is configured on a device but not directly used to encrypt data packets. Data encryption is performed using a Secure Association Key (SAK) derived from the CAK and other parameters. For details about MACsec key derivation relationships, see the [MACsec key system](#EN-US_CONCEPT_0000001513048366__section1012193110135).

#### MACsec Implementation

The implementation of MACsec between two devices comprises three stages: session negotiation, secure communication, and session keepalive.

**Figure 1** MACsec implementation  
![](figure/en-us_image_0000001512689222.png)

1. Session negotiation
   
   After the connected interfaces of the two devices are enabled with MACsec and configured with the same CAK, the two devices elect a key server through the MKA protocol. The key server generates an SAK for encrypting data packets based on the CAK and sends the SAK to the remote device.
2. Secure communication
   
   The sender uses the SAK to encrypt data packets, and the receiver uses the SAK to decrypt data packets. Both devices can function as the sender or receiver, and their communication is protected by MACsec.
3. Session keepalive
   
   The MKA protocol defines an MKA session keepalive timer that specifies the timeout period of an MKA session. After MKA session negotiation is successful, the two devices exchange MKA protocol packets to ensure that the session is alive. The local device starts the timer after receiving MKA protocol packets from the remote device.
   
   * If the local device receives subsequent MKA protocol packets within the timeout period, it restarts the timer.
   * If the local device does not receive subsequent MKA protocol packets within the timeout period, it considers the session insecure, deletes the session, and performs MKA session negotiation again.

#### MACsec Key System

After the same CAK is configured on two devices, the key server generates an SAK and sends it to the remote device, as shown in [Figure 2](#EN-US_CONCEPT_0000001513048366__fig1921453625619). The related concepts are as follows:

* CAK: The same CAK must be configured on the connected interfaces of the two devices. The CAK is not directly used to encrypt data packets. Instead, it is used together with a Connectivity Association Key Name (CKN) to derive the SAK for data encryption.
* CKN: A CKN is the name of a CAK. The same CKN must be configured on the connected interfaces of the two devices.
* SAK: An SAK is generated by the key server based on the CAK and CKN. The SAK is used to encrypt and decrypt data packets.
* Key Encrypting Key (KEK): The two devices generate the same KEK based on the same CAK and CKN. The KEK is used to encrypt and decrypt the SAK, ensuring secure transmission of the SAK.
* Integrity Check Value (ICV): The sender calculates an ICV based on a packet to be sent and adds the ICV to the end of the packet. The receiver uses the same algorithm to calculate an ICV and compares it with the ICV carried in the packet. If the two ICVs are the same, the packet is not modified and therefore passes the verification. If they are different, the packet is considered modified and is therefore discarded.
* ICV Key (ICK): The two devices generate the same ICK based on the same CAK and CKN to calculate the ICV of MKA protocol packets. The ICK is used only for the ICV calculation of MKA protocol packets. The ICV calculation of data packets does not require an ICK.

**Figure 2** MACsec key derivation relationships  
![](figure/en-us_image_0000001563888333.png)

The process of generating and installing an SAK is as follows:

1. Configure the same CAK and CKN on both devices to generate other keys.
   * Key server: generates the SAK, KEK, and ICK based on the CAK and CKN, and installs the SAK locally for encrypting and decrypting data packets.
   * Remote device: generates the KEK and ICK based on the CAK and CKN. Because the remote device has the same CAK and CKN as those of the key server, the KEK and ICK generated by the remote device are also the same as those of the key server.
2. The key server sends the SAK to the remote device through MKA protocol packets.
   * The key server uses the KEK to encrypt the SAK.
   * The key server generates an ICV based on the ICK and adds the ICV to the end of MKA protocol packets for integrity check of the packets.
   * The key server sends the encrypted SAK to the remote device through MKA protocol packets.
3. The remote device installs the SAK after receiving MKA protocol packets.
   * After receiving MKA protocol packets, the remote device searches for the matching CAK and ICK locally based on the CKN in the packets. If the matching CAK and ICK exist, the remote device performs the next step.
   * The remote device calculates an ICV based on the ICK. If the ICV is different from that carried in the packets, the packets are considered modified. If the ICVs are the same, the remote device considers the packets complete and performs the next step.
   * The remote device uses the KEK to decrypt the SAK and installs the SAK locally for encrypting and decrypting data packets.