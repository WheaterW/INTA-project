Understanding a BGP RR
======================

A full mesh of IBGP connections is needed to implement connectivity between IBGP peers within an AS. If there are *n* BGP devices in an AS, the number of IBGP connections need to be established is *n* x (*n* â 1)/2. If large numbers of IBGP peers exist, the full mesh of connections consumes a great number of network resources and CPU resources. To solve this problem, route reflection is used.

In the AS shown in [Figure 1](#EN-US_CONCEPT_0000001130783916__fig_dc_vrp_bgp_feature_000901), one BGP device functions as an RR and the other BGP devices function as its clients. Each client establishes an IBGP connection to the RR. The RR and its clients form a cluster. The RR reflects routes between clients, and therefore, the clients do not need to establish BGP connections to each other.

A BGP peer that functions as neither an RR nor a client is called a non-client. A non-client must establish full meshed connections with the RR and other non-clients.

**Figure 1** Network diagram of configuring a BGP RR  
![](figure/en-us_image_0000001176663749.png)
#### Applications

After the RR receives routes from its peers, it selects the optimal route based on BGP route selection rules and advertises learned routes to IBGP peers based on the following rules:

* If the optimal route is from a non-client IBGP peer, the RR advertises the route to all clients.
* After learning the optimal route from a client, the RR advertises the route to all non-clients and clients.
* After learning a route learned from an EBGP peer, the RR advertises the route to all clients and non-clients.

The RR is easy to configure, and you only need to configure a BGP device as an RR. The clients do not need to be specified, because they do not need to know that they are clients of the RR.

On some networks, if a full mesh of connections has already been established among clients of an RR, the clients can exchange routes with one another. In this case, the RR does not need to be configured to perform route reflection among the clients, since route reflection is unnecessary and leads to bandwidth resource consumption. Route reflection for clients through the RR can be disabled, but after that, the routes between clients and non-clients are still exchanged. By default, route reflection between clients through an RR is enabled.

BGP route attributes, such as the AS\_Path, MED, local preference, and community attributes, can be modified on the RR.


#### Originator\_ID

The Originator\_ID and Cluster\_List attributes are used to detect and prevent routing loops.

The Originator\_ID attribute is 4 bytes long and is generated by the RR. This attribute carries the router ID of the originator of the route in a local AS.

* When a route is reflected by an RR for the first time, the RR adds the Originator\_ID attribute to this route. If a route already carries an Originator\_ID, the RR does not create another one.
* After receiving the route, a BGP speaker checks whether the Originator\_ID is the same as the local router ID. If the received Originator\_ID is the same as the local router ID, the BGP speaker discards this route.

#### Cluster\_List

To prevent routing loops between ASs, a BGP device uses the AS\_Path attribute to record the ASs through which a route passes and discards routes carrying the local AS number. To prevent routing loops within an AS, routes learned from an IBGP peer within the local AS are not advertised to other IBGP peers.

With the RR deployed, IBGP peers can advertise routes learned from the local AS to each other. In this case, the Cluster\_List attribute must be used to prevent routing loops within the AS.

The RR and its clients form a cluster. In an AS, each RR uses a single Cluster\_ID to uniquely identify a cluster.

To prevent routing loops, the RR uses the Cluster\_List attribute to record the Cluster\_IDs of all RRs through which a route passes.

Similar to an AS\_Path, a Cluster\_List is composed of a series of Cluster\_IDs and records all RRs through which a route passes. The Cluster\_List is generated by the RR.

* Before an RR reflects a route between its clients or between its clients and non-clients, the RR adds the local Cluster\_ID to the top of the Cluster\_List. If the Cluster\_List is empty, the RR creates one.
* After the RR receives an updated route, it checks the Cluster\_List of the route. If the RR finds that its cluster ID is included in the Cluster\_List, the RR discards the route. If its cluster ID is not included in the Cluster\_List, the RR adds its cluster ID to the Cluster\_List and then reflects the route.

#### Backup RR

To enhance network reliability and prevent single points of failure, more than one RR needs to be configured in a cluster. RRs in the same cluster must use the same Cluster\_ID to prevent routing loops.

In an RR redundancy scenario, clients can receive multiple routes to the same destination from different RRs. The clients then use route selection rules to select the optimal route.

**Figure 2** Backup RR  
![](figure/en-us_image_0000001176663751.png)

On the network shown in [Figure 2](#EN-US_CONCEPT_0000001130783916__fig_dc_vrp_bgp_feature_000902), RR1 and RR2 are in the same cluster. RR1 and RR2 establish an IBGP connection and are non-clients for each other.

* If Client 1 receives an updated route from an external peer, Client 1 advertises the route to RR1 and RR2 through IBGP.
* After receiving the updated route, RR1 adds the local Cluster\_ID to the top of the Cluster\_List of the route and then reflects the route to other clients (Client 1, Client 2, and Client 3) and the non-client (RR2).
* After receiving the reflected route, RR2 checks the Cluster\_List and finds that its Cluster\_ID is contained in the Cluster\_List; therefore, it discards the updated route.

If RR1 and RR2 are assigned different Cluster\_IDs, each RR receives both the route from Client 1 and the updated route reflected from the other RR. Therefore, setting the same Cluster\_ID for RR1 and RR2 reduces the number of routes that each RR receives and memory consumption.

![](public_sys-resources/note_3.0-en-us.png) 

The application of the Cluster\_List ensures that routing loops do not occur between RRs in the same AS.



#### Multiple Clusters in an AS

Multiple clusters may exist in an AS. RRs are IBGP peers of each other. An RR can be configured as a client or non-client of another RR. Therefore, the relationship between clusters in an AS can be configured flexibly.

For example, the backbone network shown in [Figure 3](#EN-US_CONCEPT_0000001130783916__fig_dc_vrp_bgp_feature_000903) is divided into multiple clusters. Each RR is configured as a non-client of the other RRs, and these RRs are fully meshed. Each client establishes IBGP connections only to the RR in the same cluster. In this manner, all BGP peers in the AS can receive reflected routes. [Figure 3](#EN-US_CONCEPT_0000001130783916__fig_dc_vrp_bgp_feature_000903) shows the network diagram of multiple clusters in an AS.

**Figure 3** Network diagram of multiple clusters in an AS  
![](figure/en-us_image_0000001176663747.png)

#### Hierarchical RRs

Hierarchical reflectors are deployed on live networks. As shown in [Figure 4](#EN-US_CONCEPT_0000001130783916__fig_dc_vrp_bgp_feature_000904), the ISP provides Internet routes for AS 100, and two EBGP connections are established between the ISP and AS 100. AS 100 is divided into two clusters. The four BGP devices in Cluster 1 are core devices.

* Two Level-1 RRs (RR-1s) are deployed in Cluster 1, which ensures the reliability of key devices of AS 100. The other two BGP devices at the core layer function as clients of RR-1s.
* One Level-2 RR (RR-2) is deployed in Cluster 2. RR-2 is a client of RR-1s.

**Figure 4** Hierarchical RRs  
![](figure/en-us_image_0000001176663745.png)